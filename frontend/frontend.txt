file: index.html<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="style.css" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap"
            rel="stylesheet"
        />
        <title>GutenType</title>
    </head>
    <body>
        <div id="app">
            <div id="layout">
                <div id="menu">menu</div>
                <div id="content"></div>
                <div id="stats"><span>menu\nmenu</span></div>
                <div id="sp"></div>
                <div id="spe"></div>
            </div>
        </div>
        <script type="module" src="/main.js"></script>
    </body>
</html>
file: style.css:root {
    font-family: "JetBrains Mono", monospace;
    font-optical-sizing: auto;
    font-weight: 400;
    font-style: normal;
    --background-color: #1e1e2e;
    --main-color: #abe9b3;
    --sub-color: #575268;
    --sub-alt-color: #292739;
    --text-color: #d9e0ee;
    --error-color: #f28fad;
    --error-extra-color: #e8a2af;
    --colorful-error-color: #f28fad;
    --colorful-error-extra-color: #e8a2af;
}

#layout {
    display: grid;
    grid-template-areas:
        "sp menu spe"
        "sp content spe"
        "sp stats spe";
    grid-template-rows: 1fr 4.9rem 1fr;
    grid-template-columns: 1fr 30rem 1fr;
    position: fixed;
    padding: 0;
    margin: 0;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: var(--background-color);
    line-height: 1.5rem;
    gap: 0.2rem;
}

#content {
    grid-area: content;
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    column-gap: 0.2rem;
    row-gap: 0.2rem;
    align-content: flex-start;
    overflow-y: hidden;
}

#content > * {
    display: flex;
    gap: 0.3rem;
    justify-content: space-between;
}

.line > * {
}

.line.active {
    background-color: red;
}
.word.active {
    font-weight: bold;
}
#stats {
    grid-area: stats;
    height: 3rem;
}

.letter.active {
    text-decoration: underline;
}

#menu {
    grid-area: menu;
    height: 3rem;
}

#sp {
    grid-area: sp;
}

#spe {
    grid-area: spe;
}

.letter {
    color: var(--sub-color);
}

.typed {
    background-color: var(--sub-alt-color);
}

.correct {
    color: var(--text-color);
    display: inline-block;
    animation: drop 0.1s 1;
}

.incorrect {
    color: var(--error-color);
    display: inline-block;
    animation: wiggle 0.1s 3;
    text-decoration: underline;
}

@keyframes wiggle {
    0% {
        transform: rotate(0deg);
    }
    50% {
        transform: rotate(-7deg);
    }
    95% {
        transform: rotate(7deg);
    }
    100% {
        transform: rotate(0deg);
    }
}

@keyframes drop {
    0% {
        transform: translateY(0rem);
    }
    30% {
        transform: translateY(0.05rem);
    }
    50% {
        transform: translateY(0rem);
    }
    100% {
        transform: translateY(0rem);
    }
}
file: main.jsconst BACKEND_PROTO = "http";
const BACKEND_HOST = "127.0.0.1";
const BACKEND_PORT = 5007;

const LINE_WORD_COUND = 10;
const NEW_WORDS_GEN_LETTER_OFFSET = 30;
const LINE_LENGTH = 50;

let l = 0;
const appContainer = document.querySelector("#app");
const modifierKeys = ["Control", "Alt", "Shift", "Meta", "Tab", "Escape"];
const content = document.querySelector("#content");
let currentLetter;
let currentWord;
let currentLine;

createText();
createText();
createText();

document.addEventListener("keydown", (event) => {
    if (!currentLetter){
        currentLine = content.firstElementChild;
        currentLine.classList.add("active")

        currentWord = currentLine.firstElementChild;
        currentWord.classList.add("active")

        currentLetter = currentWord.firstElementChild;
        currentLetter.classList.add("active")

    }
    const letter = document.querySelector(`#letter_${cursor}`);
    letter.classList.remove("active");
    const currentWord = letter.closest(".word");
    if (letter === currentWord.lastElementChild) {
        currentWord.classList.remove("active");
        const nextWord = currentWord.nextElementSibling;
        if (nextWord) {
            nextWord.classList.add("active");
        }
    }
    const currentLine = currentWord.closest(".line");
    if (currentWord === currentLine.lastElementChild && letter === currentWord.lastElementChild) {
        currentLine.classList.remove("active");
        const nextLine = currentLine.nextElementSibling;
        if (nextLine) {
            nextLine.classList.add("active");
            createText();
            scrollContent();
        }
    }

    if (modifierKeys.includes(event.key)) {
        if (event.key === "Escape") {
            content.innerHTML = "";
            cursor = 0;
            l = 0;
            createText();
            return;
        }
        console.log(`modifier key pressed: ${event.key}`);
    } else if (event.code === "Backspace") {
        if (cursor !== 0) {
            letterPrev.classList.add("active");
            letterPrev.classList.remove("correct", "incorrect", "typed");
        }
        letter.classList.remove("correct", "incorrect");
        cursor = cursor === 0 ? cursor : cursor - 1;
    } else {
        letter.classList.add("typed");
        if (letter.textContent !== " ") {
            if (event.key === letter.textContent) {
                letter.classList.add("correct");
            } else {
                letter.classList.add("incorrect");
            }
        } else {
            content.scrollTop = content.scrollHeight;
        }
        cursor = cursor < l ? cursor + 1 : cursor;
    }

    console.log(`cursor at ${cursor}. key is ${event.key} (${event.code})`);
    const letterNext = document.querySelector(`#letter_${cursor}`);
    letterNext.classList.add("active");
});

function scrollContent() {
    const contentElement = document.querySelector("#content");
    const currentLine = document.querySelector(".line.active");

    if (currentLine) {
        const lineTop = currentLine.offsetTop;
        const lineHeight = currentLine.offsetHeight;
        const contentHeight = contentElement.offsetHeight;
        const targetScrollTop = lineTop - (contentHeight - lineHeight) / 2;
        contentElement.scrollTo({
            top: targetScrollTop,
            behavior: "smooth",
        });
    }
}
async function createText() {
    let wordElement;
    let words;
    try {
        words = await get_new_line(LINE_LENGTH);
    } catch (error) {
        console.error(`${error}`);
    }
    const currentLine = document.createElement("div");
    currentLine.className = "line";
    for (const [i, word] of words.entries()) {
        wordElement = document.createElement("word");
        wordElement.id = `word_${i}`;
        wordElement.className = "word";
        wordElement.word = word;
        for (let j = 0; j < word.length; j++) {
            const letter = document.createElement("letter");
            letter.id = `letter_${l++}`;
            letter.className = "letter";
            letter.textContent = word[j];
            if (j == 0) {
                letter.classList.add("first");
            }
            if (j == word.length - 1) {
                letter.classList.add("last");
            }
            wordElement.appendChild(letter);
        }
        currentLine.append(wordElement);
    }
    content.appendChild(currentLine);
}

async function get_words(n) {
    const route = `words?n=${n}`;
    try {
        const word = await send_backend_request(route);
        return word;
    } catch (error) {
        console.error(`${error}`);
    }
}

async function get_new_word() {
    const route = "word";
    try {
        const word = await send_backend_request(route);
        return word;
    } catch (error) {
        console.error(`${error}`);
    }
}

async function get_new_line(length) {
    const route = `line?length=${length}`;
    try {
        const words = await send_backend_request(route);
        return words;
    } catch (error) {
        console.log(`${error}`);
    }
}

async function send_backend_request(route) {
    try {
        const response = await fetch(
            `${BACKEND_PROTO}://${BACKEND_HOST}:${BACKEND_PORT}/${route}`,
        );
        if (!response.ok) {
            throw new Error(`HTTP response error: ${response.status}`);
        }
        const text = await response.json();
        return text;
    } catch (error) {
        throw error;
    }
}
