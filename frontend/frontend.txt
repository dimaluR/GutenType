file: index.html<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="style.css" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap"
            rel="stylesheet"
        />
        <title>GutenType</title>
    </head>
    <body>
        <div id="app">
            <div id="layout">
                <div id="menu">menu</div>
                <div id="content" class="line"></div>
                <div id="stats"><span>menu\nmenu</span></div>
                <div id="sp"></div>
                <div id="spe"></div>
            </div>
        </div>
        <script type="module" src="/main.js"></script>
    </body>
</html>
file: style.css:root {
    font-family: "JetBrains Mono", monospace;
    font-optical-sizing: auto;
    font-weight: 400;
    font-style: normal;
    --background-color: #1e1e2e;
    --main-color: #abe9b3;
    --sub-color: #575268;
    --sub-alt-color: #292739;
    --text-color: #d9e0ee;
    --error-color: #f28fad;
    --error-extra-color: #e8a2af;
    --colorful-error-color: #f28fad;
    --colorful-error-extra-color: #e8a2af;
}

#layout {
    display: grid;
    grid-template-areas:
        "sp menu spe"
        "sp content spe"
        "sp stats spe";
    grid-template-rows: 1fr 6.6rem  1fr;
    grid-template-columns: 1fr 30rem 1fr;
    position: fixed;
    padding: 0;
    margin: 0;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: var(--background-color);
    line-height: 1.5rem;
    gap: 0.2rem;
}

#content {
    grid-area: content;
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    column-gap:0.2rem;
    row-gap:0.2rem;
    align-content: flex-start;
    overflow-y: hidden;
    height: 6.6rem;
}

#content > * {
    flex: 0 0 auto;
}

#stats {
    grid-area: stats;
    height: 3rem;
}

#menu {
    grid-area: menu;
    height: 3rem;
}

#sp {
    grid-area:sp;
}

#spe {
    grid-area:spe;
}



.letter {
    color: var(--sub-color);
}

.typed {
    background-color: var(--sub-alt-color);
}

.correct {
    color: var(--text-color);
    display: inline-block;
    animation: drop 0.1s 1;
}

.incorrect {
    color: var(--error-color);
    display: inline-block;
    animation: wiggle 0.1s 3;
    text-decoration: underline;
}

.cursor {
    text-decoration: underline;
}

@keyframes wiggle {
    0% {
        transform: rotate(0deg);
    }
    50% {
        transform: rotate(-7deg);
    }
    95% {
        transform: rotate(7deg);
    }
    100% {
        transform: rotate(0deg);
    }
}

@keyframes drop {
    0% {
        transform: translateY(0rem);
    }
    30% {
        transform: translateY(0.05rem);
    }
    50% {
        transform: translateY(0rem);
    }
    100% {
        transform: translateY(0rem);
    }
}
file: main.jsconst BACKEND_PROTO = "http";
const BACKEND_HOST = "127.0.0.1";
const BACKEND_PORT = 5007;

const LINE_WORD_COUND = 10;
const NEW_WORDS_GEN_LETTER_OFFSET = 30;

let cursor = 0;
let l = 0;
const appContainer = document.querySelector("#app");
const modifierKeys = ["Control", "Alt", "Shift", "Meta", "Tab", "Escape"];
const content = document.querySelector("#content");

createText();

document.addEventListener("keydown", (event) => {
    let letterPrev;
    if (cursor !== 0) {
        letterPrev = document.querySelector(`#letter_${cursor - 1}`);
    }

    const letter = document.querySelector(`#letter_${cursor}`);
    letter.classList.remove("cursor");

    if (modifierKeys.includes(event.key)) {
        if (event.key === "Escape") {
            content.innerHTML = "";
            cursor = 0;
            l = 0;
            createText();
            return;
        }
        console.log(`modifier key pressed: ${event.key}`);
    } else if (event.code === "Backspace") {
        if (cursor !== 0) {
            letterPrev.classList.add("cursor");
            letterPrev.classList.remove("correct", "incorrect", "typed");
        }
        letter.classList.remove("correct", "incorrect");
        cursor = cursor === 0 ? cursor : cursor - 1;
    } else {
        letter.classList.add("typed");
        if (letter.textContent !== " ") {
            if (event.key === letter.textContent) {
                letter.classList.add("correct");
            } else {
                letter.classList.add("incorrect");
            }
        } else {
            content.scrollTop = content.scrollHeight;
        }
        cursor = cursor < l ? cursor + 1 : cursor;
    }

    console.log(`cursor at ${cursor}. key is ${event.key} (${event.code})`);
    if (cursor === l - NEW_WORDS_GEN_LETTER_OFFSET) {
        createText();
    } else {
        const letterNext = document.querySelector(`#letter_${cursor}`);
        letterNext.classList.add("cursor");
    }
});

async function createText() {
    let wordElement;
    let words;
    // l = 0;
    // cursor = 0;
    try {
        words = await get_words(LINE_WORD_COUND);
    } catch (error) {
        console.error(`${error}`);
    }
    for (const [i, word] of words.entries()) {
        wordElement = document.createElement("word");
        wordElement.id = `word_${i}`;
        wordElement.className = "word";
        wordElement.word = word;
        if (i === 0) {
            wordElement.classList.add("active");
        }
        for (let j = 0; j < word.length; j++) {
            const letter = document.createElement("letter");
            letter.id = `letter_${l++}`;
            letter.className = "letter";
            letter.textContent = word[j];
            if (j == 0) {
                letter.classList.add("first");
            }
            if (j == word.length - 1) {
                letter.classList.add("last");
            }
            wordElement.appendChild(letter);
        }

        content.appendChild(wordElement);
        add_space();
    }
}

function add_space() {
    const spaceElement = document.createElement("sp");

    spaceElement.id = `letter_${l++}`;
    spaceElement.className = "letter";
    spaceElement.textContent = " ";
    content.appendChild(spaceElement);
}

async function get_words(n) {
    const route = `words?n=${n}`;
    try {
        const word = await send_backend_request(route);
        return word;
    } catch (error) {
        console.error(`${error}`);
    }
}

async function get_new_word() {
    const route = "word";
    try {
        const word = await send_backend_request(route);
        return word;
    } catch (error) {
        console.error(`${error}`);
    }
}

async function send_backend_request(route) {
    try {
        const response = await fetch(
            `${BACKEND_PROTO}://${BACKEND_HOST}:${BACKEND_PORT}/${route}`,
        );
        if (!response.ok) {
            throw new Error(`HTTP response error: ${response.status}`);
        }
        const text = await response.json();
        return text;
    } catch (error) {
        throw error;
    }
}
